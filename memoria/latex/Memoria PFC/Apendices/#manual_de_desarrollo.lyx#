#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass ociamthesis-lyx
\options a4paper,titlepage
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Guía de desarrollo
\end_layout

\begin_layout Standard
La finalidad de esta sección es dar una serie de pautas de como mejorar
 y añadir nuevas características a la plataforma.
 Se espera del lector que tenga conocimientos de las tecnologías asociadas
 a la plataforma, como puede ser el uso del lenguaje Python, HTML, SQLAlchemy
 y de la plataforma Flask.
 Para adentrarse en todas estas tecnologías, puede seguir el tutorial de
 Miguel Grinberg http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-
i-hello-world
\end_layout

\begin_layout Section
Preguntas de tipo fecha
\end_layout

\begin_layout Standard
En está sección vamos a tratar de como incluir una pregunta que se espera
 una respuesta de tipo fecha.
\end_layout

\begin_layout Subsection
Modificación de la base de datos
\end_layout

\begin_layout Standard
En el fichero 
\emph on
models.py
\emph default
 podemos encontrar el mapeo objeto-relacional, ORM, de la aplicación.
 En el podemos encontrar la clase 
\emph on
Question
\emph default
, con todos los métodos y atributos asociadas a las preguntas, además podemos
 encontrar una serie de clases, que heredan de 
\emph on
Question
\emph default
 e implementa los métodos y atributos asociados a un tipo de preguntas.
 A nivel de tablas, se ha elegido que tanto la clase 
\emph on
Question
\emph default
 como todas las clases que heredan de 
\emph on
Question
\emph default
 se hallen la misma tabla.
\end_layout

\begin_layout Standard
Para crear un nuevo tipo de pregunta bastaría con la siguiente declaración:
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class QuestionDate(Question):
\end_layout

\begin_layout Plain Layout

    '''Question of type date
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    __mapper_args__ = {'polymorphic_identity': 'date'}
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Además deberíamos de crear los métodos para importar y exportar este tipo
 de preguntas a XML.
 En este caso, como no tiene ningún atributo especial no haría falta nada.
\end_layout

\begin_layout Standard
Por otra parte, para guardar la respuesta a este tipo de preguntas, tenemos
 varias opciones, desde crear una subclase de tipo 
\emph on
AnswerDate
\emph default
 que herede de 
\emph on
Answer
\emph default
 o simplemente añadir un campo de tipo 
\emph on
Date
\emph default
 a la clase 
\emph on
Answer
\emph default
.
 Este última opción ha sido la elegida:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class Answer(db.Model):
\end_layout

\begin_layout Plain Layout

    '''A table with answers
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    __tablename__ = 'answer'
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    answerDate = Column(Date)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para añadir los cambios en la base de datos, debemos de migrar la base de
 datos y actualizarla, con los siguientes comandos: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

(venv)$ ./manage.py db migrate
\end_layout

\begin_layout Plain Layout

(venv)$ ./manage.py db upgrade
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modificación del módulo Researcher
\end_layout

\begin_layout Standard
Para que el investigador pueda añadir de manera visual este tipo de preguntas
 en su encuesta, tendremos que modificar los siguientes ficheros:
\end_layout

\begin_layout Itemize

\emph on
app/researcher/views.py
\emph default
: En este fichero se encuentra la declaración de todos las funciones que
 puede hacer uso el investigador, normalmente cada función se representa
 en una página web.
\end_layout

\begin_layout Itemize

\emph on
app/researcher/forms.py
\emph default
: En este fichero se encuentra la declaración de todos las clases de formularios
 que puede hacer uso el módulo resarcher.
\end_layout

\begin_layout Itemize

\emph on
app/templates/researcher/add_edit_question.html
\emph default
: definición de la plantilla que se usa para mostrar las opciones de añadir/edit
ar preguntas.
\end_layout

\begin_layout Standard
Empezaremos por añadir el tipo de pregunta a la lista de preguntas disponibles,
 en el fichero 
\emph on
forms.py:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class QuestionForm(Form):
\end_layout

\begin_layout Plain Layout

    listQuestionType = [('yn', 'YES/NO'),
\end_layout

\begin_layout Plain Layout

            ('text','Text'),('choice','Choice'),('likertScale','Likert Scale'),(
'date','Date')]
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el fichero 
\emph on
views.py
\emph default
, procedemos a modificar la definición de 
\emph on
select_type
\emph default
, que se encarga de leer el formulario de añadir/editar preguntas y generar
 un objeto del tipo 
\emph on
Question
\emph default
 deseado:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

def selectType(form,section):
\end_layout

\begin_layout Plain Layout

    if form.questionType.data =='date':
\end_layout

\begin_layout Plain Layout

        question = QuestionDate()
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el fichero 
\emph on
add_edit_question.html
\emph default
, esta la plantilla usada para mostras las opciones disponibles.
 Además del código HTML, hay un poco de código JavaScript, para ayudar al
 investigador a la hora de rellenar las opciones, ocultando todas aquellas
 opciones (formularios) que no son necesarios para el tipo de pregunta.
\end_layout

\begin_layout Standard
En nuestro caso, interesa ocultar todas las opciones, cada vez que se selecciona
 una pregunta de tipo fecha, para ello añadiremos el siguiente código a
 la función 
\emph on
onchange_question:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

    function onchange_question(selValue)
\end_layout

\begin_layout Plain Layout

    { 
\end_layout

\begin_layout Plain Layout

        $("#divText").hide();
\end_layout

\begin_layout Plain Layout

        $("#divLikert").hide();
\end_layout

\begin_layout Plain Layout

        $("#divAnswer1").hide();
\end_layout

\begin_layout Plain Layout

        $("#divAnswer2").hide();
\end_layout

\begin_layout Plain Layout

        $("#divAnswers").hide();
\end_layout

\begin_layout Plain Layout

        $("#divRange").hide();
\end_layout

\begin_layout Plain Layout

        $("#divRender").hide();
\end_layout

\begin_layout Plain Layout

        $("#divContainer").hide();
\end_layout

\begin_layout Plain Layout

        $("#divExpectedAnswer").hide();
\end_layout

\begin_layout Plain Layout

        $("#divExpectedAnswer").hide();
\end_layout

\begin_layout Plain Layout

        $("#collapseSubquestion").collapse("hide");
\end_layout

\begin_layout Plain Layout

        if (selValue=="date")
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            //nothing to do, all options hide by default
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con esto hemos terminado las modificaciones del modulo 
\emph on
researcher
\emph default
.
\end_layout

\begin_layout Subsection
Modificación del módulo Surveys
\end_layout

\begin_layout Standard
Deberemos de modificar los ficheros 
\emph on
app/surveys/forms.py
\emph default
 y 
\emph on
app/surveys.utiles.py.
\end_layout

\begin_layout Standard
Lo primero que debemos de decidir, es como representar la fecha al usuario,
 en este caso hemos elegido el formulario de fecha por defecto que trae
 
\emph on
WTForms
\emph default
, 
\emph on
wtforms.fields.DateField
\emph default
, que comprobará automáticamente si la fecha es válida.
 
\end_layout

\begin_layout Standard
Si se desea implementar un campo y validador no disponible por WTForms,
 se pueden crear las clases necesarias, para ello consulte http://wtforms.readthe
docs.org/en/latest/ o vea los formularios y validadores creados para el proyecto
 en el fichero 
\emph on
app/surveys/forms.py.
\end_layout

\begin_layout Standard
El fichero 
\emph on
forms.py
\emph default
 tiene un aspecto diferente al que hemos observador en el anterior módulo,
 esto es básicamente porque todos los formularios se han creando dinámicamente,
 debido a que es imposible saber por defecto como va a ser el formularios.
\end_layout

\begin_layout Standard
La función que nos importa es 
\emph on
genearte_form
\emph default
, básicamente deberemos decidir que hacer cuando leamos una pregunta de
 tipo fecha, el identificador usado es 
\emph on
"c"+id
\emph default
 de la pregunta en cuestión.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

    function onchange_question(selValue)
\end_layout

\begin_layout Plain Layout

def generate_form(questions):
\end_layout

\begin_layout Plain Layout

    '''dynamically generates the forms for surveys
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    for question in questions:
\end_layout

\begin_layout Plain Layout

        if isinstance (question,QuestionDate):
\end_layout

\begin_layout Plain Layout

            if question.required:
\end_layout

\begin_layout Plain Layout

				setattr(AnswerForm,"c"+str(question.id),DateField('Answer',validators
 = [Required()]))
\end_layout

\begin_layout Plain Layout

            else:
\end_layout

\begin_layout Plain Layout

				setattr(AnswerForm,"c"+str(question.id),DateField('Answer',validators
 = [Optional()]))
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el fichero útiles deberemos de modificar la función 
\emph on
new_answer()
\emph default
 el cual genera un objeto de tipo 
\emph on
Answer
\emph default
 dependiendo del tipo de pregunta:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

def new_answer(question,form,user):
\end_layout

\begin_layout Plain Layout

    if isinstance (question,QuestionDate):
\end_layout

\begin_layout Plain Layout

        answer = Answer (answerDate = form["c"+str(question.id)].data, user=
 user, question = question)
\end_layout

\begin_layout Plain Layout

        answer.answerText = str(answer.answerDate)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el atributo answer.answerText siempre guardamos una representación del
 texto de la respuesta.
 Esto también se puede implementar con un atributo híbrido en el ORM.
\end_layout

\begin_layout Standard
Con esto ya hemos terminado una implementación básica de una pregunta de
 tipo fecha.
\end_layout

\begin_layout Section
Preguntas de tipo casillas de verificación
\end_layout

\begin_layout Standard
En está sección vamos a tratar brevemente de como incluir una pregunta,
 en la que puede haber múltiples respuestas.
\end_layout

\begin_layout Subsection
Modificación de la base de datos
\end_layout

\begin_layout Standard
Lo primero que debemos de decidir es como almacenar todas las respuestas
 posibles a la pregunta, ya sea creando una clase nueva con todas las respuestas
 posibles a una pregunta, o almacenar en la pregunta todas las respuestas
 posibles, ya sea usando una lista (PickleType), JSON, o cualquier formato
 que se nos ocurra.
\end_layout

\begin_layout Standard
En este caso hemos decidido implementarlo en una tabla nueva, para ello
 creamos primero la clase nueva, a la cual hemos añadido un nuevo atributo
 con el mínimo numero de opciones a marcar en la respuesta.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class QuestionMultipleChoices(Question): 
\end_layout

\begin_layout Plain Layout

    '''Question with multiple choices
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    __mapper_args__ = {'polymorphic_identity': 'multipleChoices'}
\end_layout

\begin_layout Plain Layout

    #: Minimum number of options
\end_layout

\begin_layout Plain Layout

    min_choices = Column(Integer, default = 0)
\end_layout

\begin_layout Plain Layout

    choices = relationship('Choice',
\end_layout

\begin_layout Plain Layout

        cascade="all, delete-orphan",
\end_layout

\begin_layout Plain Layout

        backref = 'question', lazy = 'dynamic')
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Después creamos una nueva clase con todas las opciones posibles para una
 pregunta:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class Choice (db.Model):
\end_layout

\begin_layout Plain Layout

    '''A table with Choices to a Question with multiple Choices
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    __tablename__ = 'choice'
\end_layout

\begin_layout Plain Layout

    #: unique id (automatically generated)
\end_layout

\begin_layout Plain Layout

    id = Column(Integer, primary_key = True)
\end_layout

\begin_layout Plain Layout

    #: Text for this choice
\end_layout

\begin_layout Plain Layout

    text = Column(String, nullable = False)
\end_layout

\begin_layout Plain Layout

    question_id = Column(Integer, ForeignKey('question.id'))
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entre la clase 
\emph on
Answer
\emph default
 y la clase 
\emph on
Choice
\emph default
 tendremos una relación muchos a muchos, por lo que deberemos crear una
 tabla para ella, hacemos notar que creamos una tabla y no una clase nueva,
 ya que solo lo usaremos para crear una relación entre 
\emph on
Answer
\emph default
 y 
\emph on
Choice
\emph default
, sin ningún atributo nuevo.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class Answer(db.Model):
\end_layout

\begin_layout Plain Layout

    '''A table with answers
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    __tablename__ = 'answer'
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    choices = relationship("Choice",
\end_layout

\begin_layout Plain Layout

        secondary=association_answer_choices,
\end_layout

\begin_layout Plain Layout

        backref=backref('answers', remote_side=id),
\end_layout

\begin_layout Plain Layout

        lazy = 'dynamic', uselist = True)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para añadir los cambios en la base de datos, debemos de migrar la base de
 datos y actualizarla, con los siguientes comandos:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

(venv)$ ./manage.py db migrate
\end_layout

\begin_layout Plain Layout

(venv)$ ./manage.py db upgrade
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modificación del módulo Researcher
\end_layout

\begin_layout Standard
Para modificar el módulo 
\emph on
Researcher
\emph default
 habrá que hacer una modificación análoga a la realizada en la modificación
 de añadir una pregunta de tipo fecha.
\end_layout

\begin_layout Standard
Por otro parte se podría modificar el validador del formulario para comprobar
 que el número de respuestas mínimas necesario es correcto, ya que no podemos
 pedir mas opciones de las que hay.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

    def validate(self):
\end_layout

\begin_layout Plain Layout

        if self.questionType.data == 'multiplChoices':
\end_layout

\begin_layout Plain Layout

            l = get_choices() #return list with choices
\end_layout

\begin_layout Plain Layout

            if len(l)==0:
\end_layout

\begin_layout Plain Layout

                self.errors.append("There should be a choice")
\end_layout

\begin_layout Plain Layout

            if self.min_choices.data is not None:
\end_layout

\begin_layout Plain Layout

                if self.min_choices.data>= len(get_choices()):
\end_layout

\begin_layout Plain Layout

                    self.min_choices.errors.append("minimum of choices must
 be less than the maximum")
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Además deberemos de añadir estas opciones a la base de datos: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

def selectType(form,section):
\end_layout

\begin_layout Plain Layout

    if form.questionType.data =='multiple_choices':
\end_layout

\begin_layout Plain Layout

		question = QuestionMultipleChoices(min_choices =  form.min_choices.data)
\end_layout

\begin_layout Plain Layout

        for i in get_choices():  #return list with choices
\end_layout

\begin_layout Plain Layout

            choice = Choice(text= i, question=question)
\end_layout

\begin_layout Plain Layout

            db.session.add(choice)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modificación del módulo Answer
\end_layout

\begin_layout Standard
Esta parte es análoga a la implementación de una pregunta de tipo fecha,
 solo que además añadiremos un validador para comprobar que el número marcado
 de opciones se corresponde con el mínimo exigido:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class CheckMinChoices(object):
\end_layout

\begin_layout Plain Layout

    '''check if the answer is the expected
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    def __init__(self, n, message=None):
\end_layout

\begin_layout Plain Layout

        if not message:
\end_layout

\begin_layout Plain Layout

            self.message = gettext("minimum of choices must be %i"  %n)
\end_layout

\begin_layout Plain Layout

        else:  # pragma: no cover
\end_layout

\begin_layout Plain Layout

            self.message = message
\end_layout

\begin_layout Plain Layout

        self.min_choices=n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __call__(self, form, field):
\end_layout

\begin_layout Plain Layout

        if len(form.data)<self.min_choices:
\end_layout

\begin_layout Plain Layout

            raise ValidationError(self.message)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Además cuando creemos el formulario añadiremos el validador: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

validators = [Required(),CheckMinChoices(question.min_choices)] 
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
También crearemos una lista con las opciones disponibles, cuya índice será
 el identificador de cada opción, esta lista se la pasaremos al constructor
 de
\emph on
 wtforms.fields.SelectMultipleField:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

choices = [(str(choice.id),choice.text) for choice in question.choices] 
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por último en el fichero útiles deberemos de modificar la función 
\emph on
new_answer()
\emph default
 el cual genera un objeto de tipo 
\emph on
Answer
\emph default
 dependiendo del tipo de pregunta:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

def new_answer(question,form,user):
\end_layout

\begin_layout Plain Layout

    if isinstance (question,QuestionMultipleChoice):
\end_layout

\begin_layout Plain Layout

        answer = Answer (user= user, question = question)
\end_layout

\begin_layout Plain Layout

        //obtenemos la lista de elementos marcados:
\end_layout

\begin_layout Plain Layout

        list_aux=[]
\end_layout

\begin_layout Plain Layout

        for i in form["c"+str(question.id)].data:
\end_layout

\begin_layout Plain Layout

            //obtenmos la opción marcada
\end_layout

\begin_layout Plain Layout

            choice = Choice.query.get(i)
\end_layout

\begin_layout Plain Layout

            //añadimos la opcion a la respuesta
\end_layout

\begin_layout Plain Layout

            answer.choices.append(choice)
\end_layout

\begin_layout Plain Layout

            //guardamos en una lista auxiliar la respuesta para guardarla
 también como texto
\end_layout

\begin_layout Plain Layout

            //pero no sería necesario
\end_layout

\begin_layout Plain Layout

            list_aux.append(choice.text)
\end_layout

\begin_layout Plain Layout

        answer.text = ', '.join(list_aux)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Encuestas en varios lenguajes
\end_layout

\begin_layout Standard
Puede ser muy útil tener una encuesta en múltiples idiomas, para ello la
 solución mas fácil y de las mas cómodas para el investigador es la de crear
 la encuesta en un idioma predeterminado y luego traducir esta a otros idiomas.
 La traducción se podría hacer con un simple editor de texto o integrando
 esta en la aplicación, para lo que bastaría crear una página con todos
 los textos de una encuesta e ir traduciendo.
\end_layout

\begin_layout Standard
La forma mas sencilla sería almacenar en un formato como JSON o XML el texto
 y el idioma al que pertenece.
 Todo ello guardado en el mismo atributo.
 Esta podría ser una representación de un texto guardado:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    {"language": "eng",
\end_layout

\begin_layout Plain Layout

    "text": "Hello wolrd"},
\end_layout

\begin_layout Plain Layout

    {"language": "es",
\end_layout

\begin_layout Plain Layout

    "text": "Hola Mundo"},
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para no cambiar todos los accesos a los textos, podemos hacer uso de 
\emph on
@hybrid_property
\emph default
, para devolver solo el texto en el idioma deseado o en su defecto en el
 predeterminado.
 La plataforma ya hace uso de 
\emph on
Babel
\emph default
, que es una colección de herramientas que sirve para la internacionalización
 de las aplicaciones escritas en Python, entre las funciones que tiene hay
 una que nos devuelve el idioma deseado por el usuario/navegador:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

request.accept_languages.best_match(LANGUAGES.keys())
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por lo que una clase como Survey quedaría de la siguiente manera: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class Survey(db.Model):
\end_layout

\begin_layout Plain Layout

    .....
\end_layout

\begin_layout Plain Layout

    text_json = Column(String, nullable = False)
\end_layout

\begin_layout Plain Layout

    @hybrid_property
\end_layout

\begin_layout Plain Layout

	def survey(self, language =  request.accept_languages.best_match(LANGUAGES.keys())
):
\end_layout

\begin_layout Plain Layout

        return get_text(self.text_json,language)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Encuestas con preguntas que saltan a distintas secciones
\end_layout

\begin_layout Standard
Otra mejora interesante para la plataforma, es saltar a alguna sección en
 concreto dependiendo de la respuesta dada a una pregunta.
 
\end_layout

\begin_layout Subsection
Modificación de la base de datos:
\end_layout

\begin_layout Standard
Para ello primero deberemos de crear un identificador único para cada sección
 especial.
 Podemos pensar en usar el identificador de cada sección, pero esto no es
 buena idea, ya que es la base de datos quien se encarga de administrarlo
 y puede ser poco amigable, por lo que decidimos que el nombre de la sección
 sea único.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class Section(db.Model):
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

title = Column(String(128), nullable = False)
\end_layout

\begin_layout Plain Layout

#:nos aseguramos que el titulo de la sección sea único en la encuesta
\end_layout

\begin_layout Plain Layout

__table_args__ = (UniqueConstraint('title', 'survey_id'),)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Además modificaremos las preguntas de tipo test,
\emph on
QuestionChoice
\emph default
, para que dependiendo de la respuesta dada saltemos a una sección u otra,
 para facilitar el diseño usaremos la implementación realizada para las
 preguntas con casillas de verificación, en vez de guardar los posibles
 resultados en una lista.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class QuestionChoice(Question):
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    choices = relationship('Choice',
\end_layout

\begin_layout Plain Layout

        cascade="all, delete-orphan",
\end_layout

\begin_layout Plain Layout

        backref = 'question', lazy = 'dynamic')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Choice (db.Model):
\end_layout

\begin_layout Plain Layout

    '''A table with Choices to a Question with multiple Choices
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    __tablename__ = 'choice'
\end_layout

\begin_layout Plain Layout

    #: unique id (automatically generated)
\end_layout

\begin_layout Plain Layout

    id = Column(Integer, primary_key = True)
\end_layout

\begin_layout Plain Layout

    #: Text for this choice
\end_layout

\begin_layout Plain Layout

    text = Column(String, nullable = False)
\end_layout

\begin_layout Plain Layout

    question_id = Column(Integer, ForeignKey('question.id'))
\end_layout

\begin_layout Plain Layout

    #: id de la sección a la cual se realizará el salto.
\end_layout

\begin_layout Plain Layout

    section_id = Column(Integer, ForeignKey('section.id'))
\end_layout

\begin_layout Plain Layout

    ## Relationships
\end_layout

\begin_layout Plain Layout

    section = relationship("Section")
\end_layout

\begin_layout Plain Layout

    answer = relationship("Answer")
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por último modificamos la clase 
\emph on
Answer
\emph default
, para que pueda tener una relación con la clase 
\emph on
Choice
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class Answer (db.Model):
\end_layout

\begin_layout Plain Layout

    choice = Column(Integer, ForeignKey('choice.id'))
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modificación del módulo Researcher:
\end_layout

\begin_layout Standard
Deberemos de modificar los formularios de añadir/editar sección, añadiendo
 la posibilidad de definir un identificador, por otra parte también se modificar
a la plantilla, 
\emph on
/templetes/resarcher/addEditSection.html
\emph default
 y la vista.
 
\end_layout

\begin_layout Standard
Por otra parte también habrá que modificar las opciones dadas en las preguntas
 de tipo test, permitiendo asociar a cada respuesta un salto a una sección
 dada.
 Para ello podemos usar el campo definido por la clase 
\emph on
wtforms.ext.sqlalchemy.fields.QuerySelectField
\emph default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

section = QuerySelectField ('Section',get_label='text',validators=[Optional()])
 
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
y para rellenar el formulario, que estará formado por la tupla 
\emph on
Section.id
\emph default
 y 
\emph on
title,
\emph default
 título de la sección:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

form.section.query=Question.query.filter(
\end_layout

\begin_layout Plain Layout

    Survey.id == id_survey, 
\end_layout

\begin_layout Plain Layout

    Section.root == Survey,
\end_layout

\begin_layout Plain Layout

    Section.title!=id_section //evitamos poder saltar a la misma sección
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modificación de la clase StateSurvey
\end_layout

\begin_layout Standard
Por último habrá que cambiar algo de la lógica de control de la encuesta,
 para poder realizar saltos a la sección indicada dependiendo de la respuesta
 dada.
 Cada usuario cuando empieza una encuesta, se le asocia una clase a esa
 encuesta 
\emph on
StateSurvey
\emph default
, que guarda la información relativa del usuario a esta encuesta, como puede
 ser si ha terminado la encuesta, cuanto tiempo lleva empleada en ella o
 por que sección va.
\end_layout

\begin_layout Standard
La clase tiene un método llamado 
\emph on
finishedSection
\emph default
, el cual se llama cuando se termina una sección y decide cual es la siguiente
 sección a realizar.
 Por lo que este sería un buen lugar para comprobar las respuestas dadas
 en la sección para comprobar cual es la siguiente sección a realizar.
\end_layout

\begin_layout Standard
Primero buscamos la respuesta dada a la pregunta de la cual dependerá la
 próxima sección, para simplificar el proceso hemos supuesto que solo existe
 una pregunta de este tipo por sección y que será obligatoria.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

answer = Answer.query.filter(
\end_layout

\begin_layout Plain Layout

    //obtenmos las preguntas de tipo Choice de la sección en la que estamos
\end_layout

\begin_layout Plain Layout

    QuestionChoice.section_id==self.get_section,
\end_layout

\begin_layout Plain Layout

    //obtenemos las posibles respuestas a la pregunta de tipo choice
\end_layout

\begin_layout Plain Layout

    Choice.question==QuestionChoice,
\end_layout

\begin_layout Plain Layout

    //Las posibles elecciones deben tener asociada un salto
\end_layout

\begin_layout Plain Layout

    Choice.section!=None,
\end_layout

\begin_layout Plain Layout

    // buscamos todas las respuestas del usuario
\end_layout

\begin_layout Plain Layout

    Answer.user_id==Self.user_id,
\end_layout

\begin_layout Plain Layout

    //y cogemos solo la que coincide con la pregunta
\end_layout

\begin_layout Plain Layout

    Answer.question==QuestionChoice
\end_layout

\begin_layout Plain Layout

).first()
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por lo que en 
\emph on
answer
\emph default
 tenemos la respuesta dada por el usuario de la que dependerá la siguiente
 sección.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

self.nexSection == answer.choice.section 
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Plataforma en la nube
\end_layout

\begin_layout Standard
Aquí vamos a tratar de como desplegar nuestra plataforma en la nube.
 Hemos elegido 
\emph on
Heroku
\emph default
, no sólo porque es uno de los mas populares de la red, sino porque además
 ofrece también un nivel de servicio gratuito.
\end_layout

\begin_layout Standard
Para implementar la plataforma web en 
\emph on
Heroku
\emph default
, es tan fácil como subir la aplicación usando Git.
 Para las aplicaciones desarrolladas en Python se espera un fichero 
\emph on
requirements.txt
\emph default
 en la que se encuentran todos los módulos que deben instalarse.
 
\end_layout

\begin_layout Standard
Primero nos crearemos una cuenta en Heroku y nos bajaremos el 
\emph on
"cliente Heroku"
\emph default
, una vez instalado el cliente, accederemos a nuestra cuenta y clonaremos
 nuestra plataforma desde github y crearemos la plataforma en Heroku
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

$ heroku login 
\end_layout

\begin_layout Plain Layout

$ git clone git://github.com/nu_kru/swarm-survey.git
\end_layout

\begin_layout Plain Layout

$ cd swarm-survey
\end_layout

\begin_layout Plain Layout

$ heroku create swarm-survey Creating swarm-survey...
 done, stack is cedar http://swarm-survey.herokuapp.com/ | git@heroku.com:swarm-sur
vey.git 
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con esto ya tendríamos nuestra plataforma en la nube.
 Pero aun no hemos terminado, ya que Heroku impone unas cuantas restricciones:
\end_layout

\begin_layout Itemize
Las aplicaciones que se ejecutan en Heroku no escriben archivos permanentemente
 en el disco.
\end_layout

\begin_layout Itemize
La base de datos a usar debe ser PostgreSQL
\end_layout

\begin_layout Itemize
No proporciona un servidor web
\end_layout

\begin_layout Subsection
Migración del log
\end_layout

\begin_layout Standard
Debido a que las aplicaciones que se ejecutan en Heroku no pueden escribir
 permanentemente en el disco, el log de la plataforma lo perderíamos cada
 cierto tiempo, para ello lo solucionaremos usando el log que nos proporciona
 Heroku, es mas si se observa el fichero 
\emph on
config.py
\emph default
, ya tenemos escrita una configuración por si se lanza la plataforma en
 Heroku, que se encarga de modificar el log a los requisitos de la nube
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

//log to stderr
\end_layout

\begin_layout Plain Layout

import logging
\end_layout

\begin_layout Plain Layout

from logging import StreamHandler
\end_layout

\begin_layout Plain Layout

file_handler = StreamHandler()
\end_layout

\begin_layout Plain Layout

file_handler.setLevel(logging.WARNING)
\end_layout

\begin_layout Plain Layout

app.logger.addHandler(file_handler)
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para ver el log simplemente desde el cliente escribimos:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

$ heroku logs
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esto nos mostrara todos los logs, tanto de la nube como de nuestra aplicación,
 si solo queremos ver la de la aplicación:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

$ heroku logs --source app
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Migración a PostgreSQL
\end_layout

\begin_layout Standard
La plataforma de Heroku nos proporciona una URI por la cual podemos acceder
 a nuestra base de datos, como durante el desarrollo hemos usado SQLAlchemy,
 y no hemos usado características únicas solo disponible en ciertas bases
 de datos, la migración a PostgreSQL es transparente, sin tener que realizar
 ninguna modificación en el código.
\end_layout

\begin_layout Standard
Por otra parte si se observa el fichero de configuración, la base de datos
 la obtenemos de una variable de entorno si está definida o sino de la ruta
 indicada por nosotros.
 Esta variable de entorno es la misma que usa Heroku para darnos la dirección
 de la bbdd por lo que no tendremos que realizar ningún cambio.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

class ProductionConfig(Config):
\end_layout

\begin_layout Plain Layout

    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 
\backslash

\end_layout

\begin_layout Plain Layout

        'sqlite:///' + os.path.join(basedir, 'data.sqlite')
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Servidor web
\end_layout

\begin_layout Standard
Ya que Heroku no nos proporciona ningún servidor web, en su lugar espera
 que la aplicación ejecute su propio servidor en el puerto indicado por
 la variable de entorno 
\emph on
$PORT
\end_layout

\begin_layout Standard
El servidor web proporcionado por Flask para el desarrollo no es conveniente
 usarlo en producción, ya que no es multihilo, en la documentación proporcionada
 por Heroku en las aplicaciones Python sugieren la instalación de 
\emph on
gunicorn
\emph default
, que es un servidor web escrito en Python, para hacer uso de él, lo podemos
 instalar vía 
\emph on
pip
\emph default
, para ejecutar el servidor con la aplicación tan solo debemos escribir:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

gunicorn manage.py runserver:app
\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con esto ya tendríamos todo lo necesario para ejecutar nuestra aplicación
 en Heroku.
 Si se observa detenidamente las modificaciones a hacer en la plataforma
 son nulas, sobre todo gracias a la buena definición del fichero config.py,
 en el que hemos tenido en cuenta las distintas configuraciones de la aplicación
, pasando por el modo de desarrollo al modo producción, con tres variantes
 posibles dependiendo de si la máquina contiene un sistema tipo UNIX, está
 en la nube o ninguno de estos casos.
\end_layout

\begin_layout Subsection
Requisitos de la plataforma
\end_layout

\begin_layout Standard
Durante el desarrollo de aplicaciones en Python se recomienda instalar todos
 los módulos a usar en entornos virtuales, además en nuestro caso como hemos
 hecho uso de pip para la instalación de cada módulo, podemos obtener una
 lista de todos los módulos instalados usando:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{listing}[style=consola, numbers=none]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{listing}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
[code]
\end_layout

\begin_layout Standard
pip freeze > requirements.txt
\end_layout

\begin_layout Standard
[/code]
\end_layout

\end_body
\end_document
